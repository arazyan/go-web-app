## Что такое веб-приложение?
> Веб-приложение - это кусок программного обеспечения, которое может быть доступно с использованием веб-браузера.

Во многих случаях мы будем называть веб-приложение **веб-сервером**, а браузер - **клиентом** (мобилка, десктоп и т.д.).

Когда клиент пытается обратиться к серверу, подразумевается какое-то средство коммуникации:
  * FTP
  * HTTP (наиболее распространенный)
  * WebSocket

Четыре наиболее популярных [http метода](https://developer.mozilla.org/ru/docs/Web/HTTP/Methods):
1. GET    -  предоставить ресурсы с сервера
2. PUT    -  заменить все текущие представления ресурса данными запроса
3. POST   -  обновить ресурс, добавить аттрибуты к ресурсу
4. DELETE -  удалить указанный ресурс

## Исследуем код элемента
Перейдем на вкладку Network и перезагрузим страницу. Нажмем на любой запрос и посмотрим его детальнее.

У меня это был POST-запрос:
* scheme: https 

> **https** (s - secure) более безопасный вариант протокола **http**. Протокол шифрует данные перед отправкой запроса. Приватный ключ для расшифровки данных находится (надеемся) только у вас и у сервера.

* host: aa.google.com 

> Заголовок Host содержит имя домена, для которого предназначен запрос и, опционально, номер порта. Если порт не указан, то используется умолчательный порт протокола/сервиса (например «80» для HTTP, "443" для HTTPS и т. д.)

Если мы создаем веб-приложение (сервер), то передача запроса (request) и формирование ответа (response) обратно клиенту наша ответственность.

Для ответа, который мы получим с этого запроса, существуют следующие заголовки:

* status: 200

### http статусы
* 1xx - информационный
* 2xx - успешно
* 3xx - перенаправление (на другой url)
* 4xx - ошибка клиента (что-то не так с запросом)
* 5xx - ошибка сервера

Если мы с вкладки Headers перейдем на вкладку Response, там мы увидим тело ответа. Оно может быть пустым.


## Хендлинг запросов
Сейчас у нас хендлится только корень нашего сайта - '/'. Все остальные паттерны, допустим: ```localhost:8080/ninja``` будут перенаправляться на ту же функцию, что и корень.

Зададим роутинг запросов с помощью конструкции свитч-кейсов:

```go
	switch r.URL.Path {
	case "/":
		fmt.Fprint(w, "Hello World")
	case "/whoami":
		fmt.Fprint(w, "just a sad archlinux user")
	default:
		fmt.Fprint(w, "%%%Big Fat Error!%%%")
	}
```

### Response Headers
По умолчанию Content-Type установлен "text/html". 
```go
func htmlText(w http.ResponseWriter, r *http.Request) {
	// manually set Content-Type to plain text
	w.Header().Set("Content-Type", "text/plain")

	fmt.Fprint(w, "<h1>Hello World</h1>")
}

Заголовки HTTP (англ. HTTP Headers) —  это строки в HTTP-сообщении, содержащие разделённую двоеточием пару имя-значение. Они содержат дополнительную информацию об ответе, например, его местонахождении, или о сервере, предоставившим его.

Про другие заголовки ответов (responses) можно почитать [тут.](https://developer.mozilla.org/en-US/docs/Glossary/Response_header)
```
### Конфигурация сервера
Представим, что мы хотим задать параметр **ReadTimeout** для сервера. Сделать это через ```http.ListenAndServe(":8080", nil)``` нельзя, т.к. если посмотреть на деф
иницию этой функции, она берет указатель на **Server** и передает свои параметры в этот объект, вызывая затем его функцию ```ListenAndServe()```.

```go
// definition of http.ListenAndServe()
func ListenAndServe(addr string, handler Handler) error {
  // but Server object has ReadTimeout parameter inside of it's structure
	server := &Server{Addr: addr, Handler: handler}
	return server.ListenAndServe()
}
```

Решение - задать экземпляр сервера самостоятельно.
```go
  // creating a Server instance
	server := http.Server{
		Addr:    "",
		Handler: nil,

		// manually added part
		ReadTimeout: 1000, // 1000ms=1s
    WriteTimeout: 1000,
	}
  server.ListenAndServe()
```


